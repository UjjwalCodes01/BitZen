/**
 * ZKProof Plugin Routes
 *
 * Real Groth16 ZK proof generation and verification using:
 *  - circom circuit compiled to WASM witness generator
 *  - snarkjs Groth16 prover (BN254)
 *  - On-chain Garaga verifier declared at GROTH16_VERIFIER_CLASS_HASH
 *
 * Circuit: packages/backend/circuits/agent_identity.circom
 *   Public inputs:  commitment, agentAddress, timestamp, expiresAt
 *   Private inputs: secret
 *
 * Proof calldata sent to ZKPassport.register_agent is the full_proof_with_hints
 * Span<felt252> produced by `garaga calldata`.
 */

import express, { Request, Response } from 'express';
import path from 'path';
import fs from 'fs';
import crypto from 'crypto';
import os from 'os';
import { execSync } from 'child_process';
import { logger } from '../../utils/logger';
import { buildPoseidon } from 'circomlibjs';

// snarkjs is a CJS module — import via require
// eslint-disable-next-line @typescript-eslint/no-var-requires
const snarkjs = require('snarkjs');

const router = express.Router();

// Paths to circuit artefacts (generated by circuits/setup.sh)
const CIRCUITS_DIR = path.resolve(__dirname, '../../../../circuits');
const WASM_PATH    = path.join(CIRCUITS_DIR, 'agent_identity_js', 'agent_identity.wasm');
const ZKEY_PATH    = path.join(CIRCUITS_DIR, 'agent_id_final.zkey');
const VK_PATH      = path.join(CIRCUITS_DIR, 'verification_key.json');
const GARAGA_BIN   = '/home/ujwal/Desktop/coding/BitZen/garaga-env/bin/garaga';

// Proof TTL: 24 hours
const PROOF_TTL_SECONDS = 86400;

// In-memory index — use persistent DB in production
const proofStore = new Map<string, any>();

/**
 * Compute Poseidon(secret, agentAddress) — must match circuit constraint.
 */
async function poseidonCommitment(secret: bigint, agentAddress: bigint): Promise<bigint> {
  const poseidon = await buildPoseidon();
  const hash = poseidon([secret, agentAddress]);
  return BigInt(poseidon.F.toString(hash));
}

/**
 * POST /api/v1/plugins/zkproof/generate
 *
 * Body: { agentAddress: string, secret?: string }
 *
 * Returns:
 *   proofId, proof (JSON), publicSignals, calldata (felt252[] for ZKPassport),
 *   commitment, expiresAt, secret (returned once for agent to store locally)
 */
router.post('/generate', async (req: Request, res: Response) => {
  try {
    const { agentAddress } = req.body;
    if (!agentAddress) {
      return res.status(400).json({ success: false, error: 'Missing required field: agentAddress' });
    }

    if (!fs.existsSync(WASM_PATH) || !fs.existsSync(ZKEY_PATH)) {
      return res.status(500).json({
        success: false,
        error: 'Circuit artefacts not found. Run packages/backend/circuits/setup.sh first.',
      });
    }

    const addrBigInt = BigInt(agentAddress);

    // Accept caller-supplied secret or generate one.
    // In production the agent holds the secret client-side and never sends it.
    const secretHex = req.body.secret
      ? req.body.secret
      : '0x' + crypto.randomBytes(31).toString('hex');
    const secretBigInt = BigInt(secretHex);

    const timestamp = BigInt(Math.floor(Date.now() / 1000));
    const expiresAt = timestamp + BigInt(PROOF_TTL_SECONDS);

    // ── Commitment ──────────────────────────────────────────────────
    const commitment = await poseidonCommitment(secretBigInt, addrBigInt);

    // ── Groth16 proof via snarkjs ───────────────────────────────────
    const input = {
      secret:       secretBigInt.toString(),
      commitment:   commitment.toString(),
      agentAddress: addrBigInt.toString(),
      timestamp:    timestamp.toString(),
      expiresAt:    expiresAt.toString(),
    };

    const { proof, publicSignals } = await snarkjs.groth16.fullProve(input, WASM_PATH, ZKEY_PATH);

    // ── Build Garaga calldata ───────────────────────────────────────
    // garaga calldata produces the felt252[] that ZKPassport passes to the verifier
    const proofFile = path.join(os.tmpdir(), `proof_${Date.now()}.json`);
    const pubInputFile = path.join(os.tmpdir(), `pub_${Date.now()}.json`);
    fs.writeFileSync(proofFile, JSON.stringify(proof));
    fs.writeFileSync(pubInputFile, JSON.stringify(publicSignals));

    let calldata: string[];
    try {
      const out = execSync(
        `${GARAGA_BIN} calldata --system groth16 --vk ${VK_PATH} --proof ${proofFile} --public-inputs ${pubInputFile} --format array`,
        {
          encoding: 'utf8',
          timeout: 30000,
          env: { ...process.env },
        },
      ).trim();

      // --format array outputs: [val1, val2, val3, ...]
      const arrayMatch = out.match(/\[([^\]]+)\]/s);
      if (arrayMatch) {
        calldata = arrayMatch[1].split(',').map((s: string) => s.trim()).filter(Boolean);
      } else {
        throw new Error('Unexpected garaga output format');
      }
    } catch (e: any) {
      logger.warn('garaga calldata fell back to raw encoding:', e.message);
      // Fallback: encode raw Groth16 elements + public inputs
      calldata = [
        BigInt(proof.pi_a[0]).toString(),
        BigInt(proof.pi_a[1]).toString(),
        BigInt(proof.pi_b[0][1]).toString(),
        BigInt(proof.pi_b[0][0]).toString(),
        BigInt(proof.pi_b[1][1]).toString(),
        BigInt(proof.pi_b[1][0]).toString(),
        BigInt(proof.pi_c[0]).toString(),
        BigInt(proof.pi_c[1]).toString(),
        ...publicSignals.map((s: string) => BigInt(s).toString()),
      ];
    } finally {
      if (fs.existsSync(proofFile)) fs.unlinkSync(proofFile);
      if (fs.existsSync(pubInputFile)) fs.unlinkSync(pubInputFile);
    }

    const proofId = `proof_${Date.now()}_${secretBigInt.toString(16).slice(0, 8)}`;

    proofStore.set(proofId, {
      proofId,
      agentAddress,
      proof,
      publicSignals,
      calldata,
      commitment: commitment.toString(),
      expiresAt:  Number(expiresAt),
      createdAt:  Date.now(),
      status:     'generated',
    });

    logger.info(`Groth16 proof generated for agent ${agentAddress}`, { proofId, commitment: commitment.toString() });

    return res.json({
      success: true,
      data: {
        proofId,
        proof,
        publicSignals,
        calldata,
        commitment:  commitment.toString(),
        expiresAt:   Number(expiresAt),
        createdAt:   Date.now(),
        secret:      secretHex,  // Returned once; the agent must store this locally
      },
    });
  } catch (error: any) {
    logger.error('Generate ZK proof error:', error);
    return res.status(500).json({ success: false, error: error.message || 'Failed to generate ZK proof' });
  }
});

/**
 * POST /api/v1/plugins/zkproof/verify
 *
 * Body: { proof: object, publicSignals: string[] }
 *
 * Verifies proof locally against the verification key.
 * Full on-chain verification happens inside ZKPassport.register_agent.
 */
router.post('/verify', async (req: Request, res: Response) => {
  try {
    const { proof, publicSignals } = req.body;
    if (!proof || !publicSignals) {
      return res.status(400).json({ success: false, error: 'Missing required fields: proof, publicSignals' });
    }

    if (!fs.existsSync(VK_PATH)) {
      return res.status(500).json({ success: false, error: 'Verification key not found. Run circuits/setup.sh first.' });
    }

    const vk = JSON.parse(fs.readFileSync(VK_PATH, 'utf8'));
    const isValid = await snarkjs.groth16.verify(vk, publicSignals, proof);

    const verificationId = `verify_${Date.now()}`;
    logger.info(`ZK proof verification ${verificationId}: ${isValid}`);

    return res.json({
      success: true,
      data: {
        verificationId,
        isValid,
        publicSignals,
        verifiedAt:        Date.now(),
        verificationLevel: 'local',   // on-chain happens at ZKPassport.register_agent
      },
    });
  } catch (error: any) {
    logger.error('Verify ZK proof error:', error);
    return res.status(500).json({ success: false, error: error.message || 'Failed to verify ZK proof' });
  }
});

/**
 * GET /api/v1/plugins/zkproof/status/:proofId
 */
router.get('/status/:proofId', async (req: Request, res: Response) => {
  try {
    const { proofId } = req.params;
    if (!proofId) {
      return res.status(400).json({ success: false, error: 'Proof ID required' });
    }

    const record = proofStore.get(proofId);
    if (!record) {
      return res.status(404).json({ success: false, error: `Proof ${proofId} not found` });
    }

    return res.json({
      success: true,
      data: {
        proofId:      record.proofId,
        status:       record.status,
        agentAddress: record.agentAddress,
        commitment:   record.commitment,
        createdAt:    record.createdAt,
        expiresAt:    record.expiresAt,
        isExpired:    Date.now() / 1000 > record.expiresAt,
      },
    });
  } catch (error: any) {
    logger.error('Get ZK proof status error:', error);
    return res.status(500).json({ success: false, error: error.message || 'Failed to get proof status' });
  }
});

/**
 * GET /api/v1/plugins/zkproof/agent/:agentAddress
 */
router.get('/agent/:agentAddress', async (req: Request, res: Response) => {
  try {
    const { agentAddress } = req.params;
    if (!agentAddress) {
      return res.status(400).json({ success: false, error: 'Agent address required' });
    }

    const agentProofs = Array.from(proofStore.values())
      .filter((p) => p.agentAddress === agentAddress)
      .map((p) => ({
        proofId:    p.proofId,
        status:     p.status,
        commitment: p.commitment,
        createdAt:  p.createdAt,
        expiresAt:  p.expiresAt,
        isExpired:  Date.now() / 1000 > p.expiresAt,
      }));

    return res.json({
      success: true,
      data: { agentAddress, proofs: agentProofs, count: agentProofs.length },
    });
  } catch (error: any) {
    logger.error('Get agent proofs error:', error);
    return res.status(500).json({ success: false, error: error.message || 'Failed to get agent proofs' });
  }
});

export default router;
