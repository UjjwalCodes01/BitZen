/**
 * ZKProof Plugin Routes
 *
 * Real Groth16 ZK proof generation and verification using:
 *  - circom circuit compiled to WASM witness generator
 *  - snarkjs Groth16 prover (BN254)
 *  - On-chain Garaga verifier declared at GROTH16_VERIFIER_CLASS_HASH
 *
 * Circuit: packages/backend/circuits/agent_identity.circom
 *   Public inputs:  commitment, agentAddress, timestamp, expiresAt
 *   Private inputs: secret
 *
 * Proof calldata sent to ZKPassport.register_agent is the full_proof_with_hints
 * Span<felt252> produced by `garaga calldata`.
 */

import express, { Request, Response } from 'express';
import path from 'path';
import fs from 'fs';
import crypto from 'crypto';
import os from 'os';
import { execSync } from 'child_process';
import { logger } from '../../utils/logger';
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { buildPoseidon } = require('circomlibjs') as { buildPoseidon: () => Promise<any> };
import { saveProof, getProof, listProofsByAgent } from '../../database/proofs';

// snarkjs is a CJS module — import via require
// eslint-disable-next-line @typescript-eslint/no-var-requires
const snarkjs = require('snarkjs');

const router = express.Router();

// Paths to circuit artefacts (generated by circuits/setup.sh)
const CIRCUITS_DIR = path.resolve(__dirname, '../../../../circuits');
const WASM_PATH    = path.join(CIRCUITS_DIR, 'agent_identity_js', 'agent_identity.wasm');
const ZKEY_PATH    = path.join(CIRCUITS_DIR, 'agent_id_final.zkey');
const VK_PATH      = path.join(CIRCUITS_DIR, 'verification_key.json');
// GARAGA_BIN: set GARAGA_BIN env var in production, falls back to PATH lookup
const GARAGA_BIN   = process.env.GARAGA_BIN || 'garaga';

// Proof TTL: 24 hours
const PROOF_TTL_SECONDS = 86400;


/**
 * Compute Poseidon(secret, agentAddress) — must match circuit constraint.
 */
async function poseidonCommitment(secret: bigint, agentAddress: bigint): Promise<bigint> {
  const poseidon = await buildPoseidon();
  const hash = poseidon([secret, agentAddress]);
  return BigInt(poseidon.F.toString(hash));
}

/**
 * POST /api/v1/plugins/zkproof/generate
 *
 * Body: { agentAddress: string, secret?: string }
 *
 * Returns:
 *   proofId, proof (JSON), publicSignals, calldata (felt252[] for ZKPassport),
 *   commitment, expiresAt, secret (returned once for agent to store locally)
 */
router.post('/generate', async (req: Request, res: Response) => {
  try {
    const { agentAddress } = req.body;
    if (!agentAddress) {
      return res.status(400).json({ success: false, error: 'Missing required field: agentAddress' });
    }

    const addrBigInt = BigInt(agentAddress);

    if (!fs.existsSync(WASM_PATH) || !fs.existsSync(ZKEY_PATH)) {
      logger.warn('Circuit artefacts not found — returning mock proof for demo/dev mode');

      const mockSecret = BigInt('0x' + crypto.randomBytes(31).toString('hex'));
      const commitment = await poseidonCommitment(mockSecret, addrBigInt);
      const secretHex  = '0x' + crypto.randomBytes(31).toString('hex');
      const timestamp  = BigInt(Math.floor(Date.now() / 1000));
      const expiresAt  = timestamp + BigInt(PROOF_TTL_SECONDS);
      const proofId    = `mock_proof_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;

      const mockProof = {
        pi_a: [crypto.randomBytes(32).toString('hex'), crypto.randomBytes(32).toString('hex'), '1'],
        pi_b: [[crypto.randomBytes(32).toString('hex'), crypto.randomBytes(32).toString('hex')], [crypto.randomBytes(32).toString('hex'), crypto.randomBytes(32).toString('hex')], ['1', '0']],
        pi_c: [crypto.randomBytes(32).toString('hex'), crypto.randomBytes(32).toString('hex'), '1'],
        protocol: 'groth16',
        curve: 'bn128',
      };
      const mockPublicSignals = [commitment.toString(), addrBigInt.toString(), timestamp.toString(), expiresAt.toString()];
      const mockCalldata = [`0x${crypto.randomBytes(32).toString('hex')}`, `0x${crypto.randomBytes(32).toString('hex')}`];

      await saveProof({
        proofId,
        agentAddress,
        proof:         mockProof,
        publicSignals: mockPublicSignals,
        calldata:      mockCalldata,
        commitment:    commitment.toString(),
        expiresAt:     Number(expiresAt),
        createdAt:     Date.now(),
        status:        'generated',
      });

      return res.json({
        success: true,
        data: {
          proofId,
          proof:         mockProof,
          publicSignals: mockPublicSignals,
          calldata:      mockCalldata,
          commitment:    commitment.toString(),
          expiresAt:     Number(expiresAt),
          createdAt:     Date.now(),
          secret:        secretHex,
          _mock:         true,
        },
      });
    }

    // Accept caller-supplied secret or generate one.
    // In production the agent holds the secret client-side and never sends it.
    const secretHex = req.body.secret
      ? req.body.secret
      : '0x' + crypto.randomBytes(31).toString('hex');
    const secretBigInt = BigInt(secretHex);

    const timestamp = BigInt(Math.floor(Date.now() / 1000));
    const expiresAt = timestamp + BigInt(PROOF_TTL_SECONDS);

    // ── Commitment ──────────────────────────────────────────────────
    const commitment = await poseidonCommitment(secretBigInt, addrBigInt);

    // ── Groth16 proof via snarkjs ───────────────────────────────────
    const input = {
      secret:       secretBigInt.toString(),
      commitment:   commitment.toString(),
      agentAddress: addrBigInt.toString(),
      timestamp:    timestamp.toString(),
      expiresAt:    expiresAt.toString(),
    };

    const { proof, publicSignals } = await snarkjs.groth16.fullProve(input, WASM_PATH, ZKEY_PATH);

    // ── Build Garaga calldata ───────────────────────────────────────
    // garaga calldata produces the felt252[] that ZKPassport passes to the verifier
    const proofFile = path.join(os.tmpdir(), `proof_${Date.now()}.json`);
    const pubInputFile = path.join(os.tmpdir(), `pub_${Date.now()}.json`);
    fs.writeFileSync(proofFile, JSON.stringify(proof));
    fs.writeFileSync(pubInputFile, JSON.stringify(publicSignals));

    let calldata: string[];
    // Use --format snforge which outputs one hex string per line.
    // CRITICAL: --format array outputs JSON numbers which JavaScript JSON.parse
    // truncates to float64 (~53 bits). Garaga values need up to 96 bits.
    // --format snforge avoids this precision loss entirely.
    const calldataFile = path.join(os.tmpdir(), `garaga_calldata_${Date.now()}.txt`);
    try {
      execSync(
        `${GARAGA_BIN} calldata --system groth16 --vk ${VK_PATH} --proof ${proofFile} --public-inputs ${pubInputFile} --format snforge --output-path ${path.dirname(calldataFile)}`,
        {
          encoding: 'utf8',
          timeout: 60000,
          env: { ...process.env },
        },
      );
      // garaga writes to <output-path>/proof_calldata.txt
      const snforgeOut = path.join(path.dirname(calldataFile), 'proof_calldata.txt');
      calldata = fs.readFileSync(snforgeOut, 'utf8').trim().split('\n').map((l: string) => l.trim()).filter(Boolean);
      if (calldata.length === 0) throw new Error('Empty garaga output');
      logger.info(`Garaga calldata generated: ${calldata.length} felt252 elements`);
    } catch (e: any) {
      logger.error('garaga calldata failed:', e.message);
      throw new Error(`Failed to generate garaga calldata: ${e.message}. Ensure GARAGA_BIN is set and the garaga CLI is installed.`);
    } finally {
      if (fs.existsSync(proofFile)) fs.unlinkSync(proofFile);
      if (fs.existsSync(pubInputFile)) fs.unlinkSync(pubInputFile);
      if (fs.existsSync(calldataFile)) fs.unlinkSync(calldataFile);
    }

    const proofId = `proof_${Date.now()}_${secretBigInt.toString(16).slice(0, 8)}`;

    await saveProof({
      proofId,
      agentAddress,
      proof,
      publicSignals,
      calldata,
      commitment: commitment.toString(),
      expiresAt:  Number(expiresAt),
      createdAt:  Date.now(),
      status:     'generated',
    });

    logger.info(`Groth16 proof generated for agent ${agentAddress}`, { proofId, commitment: commitment.toString() });

    return res.json({
      success: true,
      data: {
        proofId,
        proof,
        publicSignals,
        calldata,
        commitment:  commitment.toString(),
        expiresAt:   Number(expiresAt),
        createdAt:   Date.now(),
        secret:      secretHex,  // Returned once; the agent must store this locally
      },
    });
  } catch (error: any) {
    logger.error('Generate ZK proof error:', error);
    return res.status(500).json({ success: false, error: error.message || 'Failed to generate ZK proof' });
  }
});

/**
 * POST /api/v1/plugins/zkproof/verify
 *
 * Body: { proof: object, publicSignals: string[] }
 *
 * Verifies proof locally against the verification key.
 * Full on-chain verification happens inside ZKPassport.register_agent.
 */
router.post('/verify', async (req: Request, res: Response) => {
  try {
    const { proof, publicSignals } = req.body;
    if (!proof || !publicSignals) {
      return res.status(400).json({ success: false, error: 'Missing required fields: proof, publicSignals' });
    }

    if (!fs.existsSync(VK_PATH)) {
      return res.status(500).json({ success: false, error: 'Verification key not found. Run circuits/setup.sh first.' });
    }

    const vk = JSON.parse(fs.readFileSync(VK_PATH, 'utf8'));
    const isValid = await snarkjs.groth16.verify(vk, publicSignals, proof);

    const verificationId = `verify_${Date.now()}`;
    logger.info(`ZK proof verification ${verificationId}: ${isValid}`);

    return res.json({
      success: true,
      data: {
        verificationId,
        isValid,
        publicSignals,
        verifiedAt:        Date.now(),
        verificationLevel: 'local',   // on-chain happens at ZKPassport.register_agent
      },
    });
  } catch (error: any) {
    logger.error('Verify ZK proof error:', error);
    return res.status(500).json({ success: false, error: error.message || 'Failed to verify ZK proof' });
  }
});

/**
 * GET /api/v1/plugins/zkproof/status/:proofId
 */
router.get('/status/:proofId', async (req: Request, res: Response) => {
  try {
    const { proofId } = req.params;
    if (!proofId) {
      return res.status(400).json({ success: false, error: 'Proof ID required' });
    }

    const record = await getProof(proofId);
    if (!record) {
      return res.status(404).json({ success: false, error: `Proof ${proofId} not found` });
    }

    return res.json({
      success: true,
      data: {
        proofId:      record.proofId,
        status:       record.status,
        agentAddress: record.agentAddress,
        commitment:   record.commitment,
        createdAt:    record.createdAt,
        expiresAt:    record.expiresAt,
        isExpired:    Date.now() / 1000 > record.expiresAt,
      },
    });
  } catch (error: any) {
    logger.error('Get ZK proof status error:', error);
    return res.status(500).json({ success: false, error: error.message || 'Failed to get proof status' });
  }
});

/**
 * GET /api/v1/plugins/zkproof/agent/:agentAddress
 */
router.get('/agent/:agentAddress', async (req: Request, res: Response) => {
  try {
    const { agentAddress } = req.params;
    if (!agentAddress) {
      return res.status(400).json({ success: false, error: 'Agent address required' });
    }

    const rawProofs = await listProofsByAgent(agentAddress);
    const agentProofs = rawProofs.map((p) => ({
      proofId:    p.proofId,
      status:     p.status,
      commitment: p.commitment,
      createdAt:  p.createdAt,
      expiresAt:  p.expiresAt,
      isExpired:  Date.now() / 1000 > p.expiresAt,
    }));

    return res.json({
      success: true,
      data: { agentAddress, proofs: agentProofs, count: agentProofs.length },
    });
  } catch (error: any) {
    logger.error('Get agent proofs error:', error);
    return res.status(500).json({ success: false, error: error.message || 'Failed to get agent proofs' });
  }
});

export default router;
